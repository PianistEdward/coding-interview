# Java并发编程

<!--基于《Java并发编程的艺术》-->

## 一、并发编程的挑战

### 1.1 上下文切换

1.1 测试上下文切换次数和时长

Lmbench3可以测量上下文切换的时长。

vmstat可以测量上下文切换的次数。

vmstat命令：CS（Content Switch）表示上下文切换的次数。

### 1.2 死锁

死锁排查：jps+jstack

`jps -l `

`jstack -l PID`

`jstack PID| grep 'waiting to lock'`

也可以用jdk自带的jconsole，jvisualvm，开源工具arthas。

## 二、底层实现原理

### 2.1 volatile

1、CPU术语

内存屏障、缓冲行、原子操作、缓冲行填充、缓存命中、写命中、写缺失

2、lock前缀的指令

1）将当前处理器缓存行的数据写回到系统内存

2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

3、缓存一致性协议

4、追加64个字节，优化volatile性能

一个对象的引用占4个字节。

L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。

### 2.2 synchronized

Java中的每一个对象都可以作为锁。

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步方法块，锁是Synchonized括号里配置的对象。

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

2.2.1 Java对象头

synchronized用的锁是存在Java对象头里的。

Java对象头的存储结构？

2.2.2 锁的升级与对比

JDK1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状
态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。

1）偏向锁

什么是偏向锁？

偏向锁的获得？

偏向锁的撤销？

JVM参数关闭偏向锁。

2）轻量级锁

3）重量级锁

不同锁的适用场景？优缺点？

### 2.3 原子操作

缓存操作的最小单位

CPU流水线

内存顺序冲突

伪共享

处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

缺点：

1）ABA问题

2）只能保证一个共享变量的原子操作

## 三、Java内存模型





